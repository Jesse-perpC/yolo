{"name":"Yolo","tagline":"Log tailing and parsing framework in Java","body":"# Yolo [![Build Status](https://travis-ci.org/ustream/yolo.png?branch=master)](https://travis-ci.org/ustream/yolo)\r\n\r\n**You only log once but you can easily parse your data as many ways as you want.**\r\n\r\nA general log tailer and parser tool written in Java, inspired by [Parsible](https://github.com/Yipit/parsible) and [Logster](https://github.com/etsy/logster). It is easily extensible with new parsers and processors. The main purpose was to build a simple tool to get metrics values and errors from log files and report to [StatsD](https://github.com/etsy/statsd/) (and [Graphite](http://graphite.wikidot.com/)), but everyone can write custom modules in minutes.\r\n\r\n## Main concepts\r\n\r\n* **Flexible configuration**: the configuration is in JSON format for easier management. You can define your parsers and processors and bind them as you want.\r\n* **Real time**: the tool tails the log file realtime\r\n* **Whole file reading**: with a cli parameter you can read your logfile from the beginning\r\n* **Handle dynamic filenames**: you can use wildcards in filename (but only the first match will be used)\r\n* **Logrotate friendly**: works easily with logrotate or other log rotating tools\r\n* **Easily debuggable**: debug mode writes verbose logs, and you can use built-in parsers and processors for debugging purposes\r\n\r\n## Notice\r\n\r\nBecause we tail the log file and the application can stop anytime therefore it is not guaranteed that the tool will parse all the lines. In the near future we plan to implement a secure reader which stores the read offset and handles even log rotate events.\r\n\r\n## Modules\r\n\r\nEach module is stateless, has a description and predefined configuration.\r\n\r\n* **Parser**: the parser parses a log line and returns with parameters (a map).\r\n* **Processor**: the processor gets the parser's parameters and does anything with them, like send key/values to StatsD\r\n\r\n## Process\r\n\r\n* the file tailer reads a new line from the file\r\n* the handler iterates through all the parsers and finds the first which returns with a non-null value\r\n* the output value is passed to the given processor with the \"processParams\" configuration given in the config\r\n* the processor processes the data\r\n* the handler runs all the parsers (regardless the first match) which runs always. (currently it is only the passthru parser)\r\n\r\n## Build\r\n\r\nThe project uses Gradle and it is embedded with a Gradle wrapper.\r\n\r\n```bash\r\n# run tests, if you want\r\n./gradlew test\r\n\r\n# create runnable jar file\r\n./gradlew jar\r\n\r\n# check if it works\r\njava -jar build/libs/yolo.jar -help\r\n```\r\n\r\n### Build Debian package\r\n\r\n```bash\r\n./gradlew debian\r\n```\r\n\r\nThe .deb file will be placed in the build/linux-package directory.\r\n\r\nThe package contains the runnable jar file, which will be copied to /usr/lib/yolo when installed.\r\n\r\n## Sample configuration\r\n\r\nAn example config file can be found in [example.json](src/main/config/example.json).\r\n\r\n## Command line parameters\r\n\r\nSimply run the jar with \"-help\" option.\r\n\r\n```bash\r\n$ java -jar build/libs/yolo.jar -help\r\nusage: yolo\r\n -config <path>   path to config file\r\n -file <path>     path to logfile, , wildcards are accepted\r\n -help            print this message\r\n -listModules     list available modules\r\n -reopen          reopen file between reading the chunks\r\n -whole           tail file from the beginning\r\n```\r\n\r\n## Example usage\r\n\r\n```bash\r\n$ java -jar build/libs/yolo.jar -config /YOURPATH/src/main/config/example.json -file /YOURPATH/foo.log\r\n```\r\n\r\n## Available modules\r\n\r\nSimply run the jar with \"-listModules\" option.\r\n\r\n```bash\r\n$ java -jar build/libs/yolo.jar -listModules\r\n\r\nAvailable processors\r\n--------------------\r\n\r\n* tv.ustream.yolo.module.processor.CompositeProcessor - runs multiple processors\r\n  - params: Map {\r\n      class: String, required\r\n      processors: List, required\r\n    }\r\n\r\n* tv.ustream.yolo.module.processor.ConsoleProcessor - writes parameters to console, use it for debug purposes\r\n  - params: Map {\r\n      class: String, required\r\n    }\r\n\r\n* tv.ustream.yolo.module.processor.GraphiteProcessor - sends metrics to Graphite\r\n  - params: Map {\r\n      port: Number, default: 2003\r\n      host: String, required\r\n      class: String, required\r\n      flushTimeMs: Number, default: 1000\r\n    }\r\n  - processParams: Map {\r\n      keys: List [\r\n        Map {\r\n          timestamp: String, pattern allowed\r\n          value: String|Number, required, pattern allowed\r\n          multiplier: Number, default: 1\r\n          key: String, required, pattern allowed\r\n        }\r\n      ]\r\n    }\r\n\r\n* tv.ustream.yolo.module.processor.StatsDProcessor - sends metrics to StatsD, handles counter, gauge and timing values\r\n  - params: Map {\r\n      port: Number, default: 8125\r\n      host: String, required\r\n      prefix: String, required\r\n      class: String, required\r\n    }\r\n  - processParams: Map {\r\n      keys: List [\r\n        Map {\r\n          value: String|Number, required, pattern allowed\r\n          type: String, required, allowed values: [counter, gauge, timer]\r\n          multiplier: Number, default: 1\r\n          key: String, required, pattern allowed\r\n        }\r\n      ]\r\n    }\r\n\r\nAvailable parsers\r\n-----------------\r\n\r\n* tv.ustream.yolo.module.parser.PassThruParser - forwards all lines to processor, runs always\r\n  - params: Map {\r\n      enabled: Boolean, default: true\r\n      class: String, required\r\n      processor: String, required\r\n      processParams: Map\r\n    }\r\n\r\n* tv.ustream.yolo.module.parser.RegexpParser - parses line via regular expression and returns with matches\r\n  - params: Map {\r\n      enabled: Boolean, default: true\r\n      regex: String, required\r\n      class: String, required\r\n      processor: String, required\r\n      processParams: Map\r\n    }\r\n\r\n```\r\n\r\n## Create your own parser\r\n\r\nCheck [RegexpParser](src/main/java/tv/ustream/yolo/module/parser/RegexpParser.java) for a compact example.\r\n\r\nIf you are ready, add your parser class to ModuleFactory.availableParsers.\r\n\r\n```java\r\npublic class TestParser implements IParser\r\n{\r\n\r\n    @Override\r\n    public Map<String, String> parse(String line)\r\n    {\r\n        // parse a line here and return with null if no match happened or with a Map if you want to process it\r\n    }\r\n\r\n    @Override\r\n    public boolean runAlways()\r\n    {\r\n        // return with true if you want the module to always run for every line regardless of the first match\r\n    }\r\n\r\n    @Override\r\n    public List<String> getOutputKeys()\r\n    {\r\n        // return with the keys you will return in parse\r\n    }\r\n\r\n    @Override\r\n    public void setUpModule(Map<String, Object> parameters)\r\n    {\r\n        // read the config and set up your parser\r\n    }\r\n\r\n    @Override\r\n    public ConfigMap getModuleConfig()\r\n    {\r\n        // build your module's config\r\n    }\r\n\r\n    @Override\r\n    public String getModuleDescription()\r\n    {\r\n        // return with a simple description for your module\r\n    }\r\n}\r\n```\r\n\r\n## Create your own processor\r\n\r\nCheck [StatsDProcessor](src/main/java/tv/ustream/yolo/module/processor/StatsDProcessor.java) for a compact example.\r\n\r\nIf you are ready, add your processor class to ModuleFactory.availableProcessors.\r\n\r\n```java\r\npublic class TestProcessor implements IProcessor\r\n{\r\n\r\n    @Override\r\n    public ConfigMap getProcessParamsConfig()\r\n    {\r\n        // build the processParams config for parsers\r\n    }\r\n\r\n    @Override\r\n    public void process(Map<String, String> parserOutput, Map<String, Object> processParams)\r\n    {\r\n        // process the parser's output. The processParams map can contain ConfigPattern objects where you can subtitute your own values\r\n    }\r\n\r\n    @Override\r\n    public void setUpModule(Map<String, Object> parameters)\r\n    {\r\n        // read configuration and set up your processor\r\n    }\r\n\r\n    @Override\r\n    public ConfigMap getModuleConfig()\r\n    {\r\n        // build your module's config\r\n    }\r\n\r\n    @Override\r\n    public String getModuleDescription()\r\n    {\r\n        // return with a simple description for your module\r\n    }\r\n\r\n\t@Override\r\n\tpublic void stop()\r\n\t{\r\n\t\t// here you can stop your processor gracefully\r\n\t}\r\n\r\n}\r\n```\r\n\r\n## Module configuration handling\r\n\r\nThe configuration is validated with ConfigMap objects which can be built the following way.\r\n\r\n```java\r\nConfigMap config = new ConfigMap();\r\n\r\n// add \"key1\" key with string type, the value will be required\r\nconfig.addConfigValue(\"key1\", String.class);\r\n\r\n// add \"key2\" key with number type, the value will be optional, and the default value will be 5\r\nconfig.addConfigValue(\"key1\", Number.class, false, 5);\r\n\r\n// add \"key3\" key with string|number type\r\nConfigValue<Object> configValue = new ConfigValue<Object>(\"key3\", Object.class);\r\nconfigValue.setAllowedTypes(Arrays.<Class>asList(String.class, Number.class));\r\nconfig.addConfigValue(configValue);\r\n\r\n// add \"key4\" key as an enumeration\r\nConfigValue<String> configValue = new ConfigValue<String>(\"key4\", String.class);\r\nconfigValue.setAllowedValues(Arrays.asList(\"value1\", \"value2\"));\r\nconfig.addConfigValue(configValue);\r\n\r\n// add \"key5\" key which allows a config pattern\r\nConfigValue<String> configValue = new ConfigValue<String>(\"key5\", String.class);\r\nconfigValue.allowConfigPattern();\r\nconfig.addConfigValue(configValue);\r\n```\r\n\r\n### Config patterns\r\n\r\nConfig pattern means a string value with key placeholders, like 'this is #type#'. This can be used in the process parameters configuration, when you want to substitute values from the parser output in the process config.\r\n\r\nIf you check the [configuration example](src/main/config/example.json), you can see that the statsd process parameters contain expressions like #exceptionName# or #val#, these values will be substituted from the regexp matches.\r\n\r\n## Logging\r\n\r\nThe tool uses [SLF4J](http://www.slf4j.org/) for logging with the SimpleLogger implementation. The minimum log level is INFO and all the logs are written to the standard error output.\r\n\r\nTo display debug messages use the -Dorg.slf4j.simpleLogger.defaultLogLevel=debug option.\r\n\r\n```bash\r\n$ java -Dorg.slf4j.simpleLogger.defaultLogLevel=debug -jar build/libs/yolo.jar -config /YOURPATH/src/main/config/example.json -file /YOURPATH/foo.log\r\n```\r\n\r\n## Dependencies\r\n\r\nFor a detailed dependency list please check the \"dependencies\" block in [build.gradle](build.gradle).\r\n\r\n**Compile dependencies**:\r\n\r\n* [Apache Commons CLI](http://commons.apache.org/proper/commons-cli/)\r\n* [Apache Commons IO](http://commons.apache.org/proper/commons-io/)\r\n* [Gson](http://code.google.com/p/google-gson/)\r\n* [java-statsd-client](https://github.com/youdevise/java-statsd-client)\r\n* [SLF4j](http://www.slf4j.org/)\r\n\r\n**Testing dependencies**:\r\n\r\n* [JUnit](http://junit.org/)\r\n* [Mockito](http://code.google.com/p/mockito/)\r\n\r\n## Contributing\r\n\r\nFeel free to fork this project and send pull requests if you want to help us improve the tool or add new parsers/processors. But before sending us new modules, please think through if the module serves a general purpose and whether it will be useful for others, not just for you.\r\n\r\n## Licence\r\n\r\nThis project is licensed under the terms of the [MIT License (MIT)](LICENCE.md).\r\n\r\n## Authors\r\n\r\n* [bandesz](https://github.com/bandesz)\r\n","google":"UA-43771276-1","note":"Don't delete this file! It's used internally to help with page regeneration."}